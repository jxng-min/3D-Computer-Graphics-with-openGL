## OpenGL 개괄

</br>
</br>

### 4.3.1 API 레벨

</br>

![화면 캡처 2024-10-29 231751](https://github.com/user-attachments/assets/3e59ce9e-87f2-43bc-a8e2-db64efb8156d)

</br>

위의 그림은 표준 및 API의 발전 과정을 나타낸다.

</br>

3D 그래픽 프로그램과 개인용 컴퓨터를 이용하여 3D 응용프로그램을 개발할 수 있게 되었다.

개발자의 입장에서는 **프로그램을 얼마나 수월하게 작성할 수 있는가**가 가장 큰 관건이며, API는 이를 위해 존재한다.

**API**는 프로그래밍 언어가 아닌 **프로그래밍 언어를 사용하여 작성된 라이브러리 함수**다.

따라서 개발자는 API를 이용하여 원하는 그래픽 프로그램을 작성할 수 있다.

</br>

3D API 시장을 오랫동안 주도해 온 사실 표준은 OpenGL이다. API 수준에서 **OpenGL은 저수준 API**다.

따라서 OpenGL은 **묘사된 내용으로부터 그 장면을 그려내기 위해 필요한 구체적인 프로시저**에 해당한다.

이런 점에서 OpenGL은 OpenInventer, VRML, Java3D 등 **고수준 인터페이스의 기반**이 된다.

즉, 고수준 인터페이스도 결국 **OpenGL 인터페이스 함수를 내부적으로 호출**하여 프로그램을 실행한다.

</br>

OpenGL과 마찬가지로 저수준 API에 속하는 것이 **Direct 3D**다.

이는 Microsoft의 DirectX 미디어 라이브러리의 일부로, **게임 프로그램에 주로 사용**되며 상대적으로 **매우 복잡한 API**에 속한다.

Direct 3D는 **DirectDraw 라이브러리 함수를 바탕으로 구성된 라이브러리**로 작성을 위해서는 DirectDraw 라이브러리를 알아야만 했다.

Direct 3D의 가장 큰 단점은 **Microsoft Windows 계열**에서만 돌아간다. 즉, **호환성이 없다**는 점이다.

</br>

개발자의 입장에서는 고수준 API가 저수준 API보다 사용하기 용이하다. 그러나 문제는 간단하지 않다.

일반적으로 **설계가 너무 추상적으로 진행되면 구체적인 내용을 변경할 수 없다**.

</br>

OpenGL의 장점은 이것이다. 고수준 API에서는 추상적인 함수만을 허용해서 세부적으로 그 함수 내부의 명령이나 변수의 일부를 변경할 수 없다.

OpenGL은 그래픽 메모리, 그래픽 가속 칩 등의 **하드웨어와 매우 근접**하여 이들을 **직접 제어**하여 하드웨어 **성능을 최대한 발휘**시킬 수 있다.

</br>

![제목 없는 다이어그램 drawio (3)](https://github.com/user-attachments/assets/1f00fd36-0cf7-4023-bc20-1408ff378e38)

</br>

위의 그림은 OpenInventor를 예로 들어 OpenGL의 상대적인 위치를 나타낸 그림이다.

장면 묘사를 허용하는 고수준 API인 OpenInventor는 **결국 저수준 API인 OpenGL로 변환**된다. 

그러나 **OpenGL 역시 하드웨어를 직접 제어하지는 않는다**. 개발자가 하드웨어를 일일히 제어하는 것은 어렵다.

OpenGL도 드라이버 소프트웨어에 비해서는 상대적으로 고수준 함수여서, 결국은 **디바이스 드라이버를 통해 하드웨어 제어 명령으로 번역**된다.

</br>

**모든 3차원 물체 표면은 평면 삼각형의 집합으로 근사**시킬 수 있다.

그래픽 처리는 **기본 요소를 정의하고 조합하여 복잡한 물체를 설계**하는 **모델링** 작업과 **모델링된 물체를 화면에 그려내는 렌더링** 작업으로 나눌 수 있다.

</br>

고수준 API에서는 모델링에 치중하지만 저수준 API인 **OpenGL은 렌더링에 치중**한다.

OpenGL은 저수준 API이기 때문에 점, 선, 다각형 수준의 **기본 요소만을 이해**한다.

따라서 OpenGL에서는 고수준 API처럼 물체를 원구, 원기둥 등의 차원에서 정의할 수 없다.

정리하면 물체가 단순하든, 복잡하든 **이미 설계된 물체를 화면에 그려내기 위한 것이 OpenGL**이다.

</br>

같은 저수준 API인 DirectX에 비해 OpenGL이 사실 표준으로 인정받는 이유는 **너무 많은 것을 하려고 하지 않기 때문**이다.

OpenGL은 물체를 설계하거나, 윈도우를 조작하거나, 세련된 애니메이션을 가하거나, 소리를 추가하는 작업 등을 할 수 없다. **단지 이미 설계된 물체를 그려낼 뿐**이다.

하지만 **렌더링에 관련된 작업에서의 OpenGL은 다양하고 유용한 기능을 고속으로 처리**한다.

</br>

OpenGL에서 Open이 의미하는 바와 같이 **GL의 소스는 공개**되어 있다. 이는 GL 시장이 확장되길 바라는 SGI 사의 방침이다.

</br>
</br>

### 4.3.2 OpenGL의 설계 원리

</br>

**OpenGL은 C 또는 어셈블리어로 작성**된 약 200여 개의 함수로 구현되어 있다.

C뿐만 아니라 **C++, Ada, FORTRAN, Java도 OpenGL API를 호출하여 사용**할 수 있다.

OpenGL 개발에 있어서 고려된 설계 원리를 몇 가지로 요약해보자.

</br>

* 범용성
    + OpenGL은 거의 **대부분의 하드웨어에서 실행**될 수 있도록 설계되었다.
    + OpenGL은 소프트웨어적인 측면에서 **운영체제와 무관**하게 설계되었다.

* 효율성
    + OpenGL은 주어진 기능을 프로그램에 의해 활성화/비활성화 할 수 있도록 **기능 모드를 제공**한다.

* 독립성
    + 어떤 기능을 활성화/비활성화 모드로 변경하는 행위가 다른 기능에 영향을 미쳐서는 안된다.
    + **기능끼리 서로 얽혀 발생하는 오류를 방지**한다.

* 완전성
    + OpenGL은 **특정 하드웨어 기능에 대해서는 ARB 확장 형태로 명령어를 제공**함으로써 그래픽 하드웨어 성능을 최대로 발휘한다.
    + 다수의 하드웨어가 확장 기능을 지원한다면 그 기능을 OpenGL의 표준 기능으로 변경된다.
    + 특정한 하드웨어만 확장 기능을 지원한다면 **이식성이 저해**된다.

* 상호작업성
    + OpenGL은 **Client-Server 모델을 사용**하여 상대적으로 성능이 낮은 클라이언트 컴퓨터가 고성능 서버를 이용할 수 있다.

</br>
</br>

### 4.3.3 파이프라인과 상태 변수

</br>

CPU의 처리 속도를 개선한 것이 파이프라인이듯, 그래픽 보드 내부의 **GPU의 처리 속도를 개선**한 것이 **파이프라인** 구조다.

</br>

![제목 없는 다이어그램 drawio (5)](https://github.com/user-attachments/assets/8a910265-6898-4456-a7b6-42db147cfbac)

</br>

**OpenGL의 입력은 기하 기본 요소와 영상 기본 요소로 구성**된다.

**기하 기본 요소**는 **3D의 점, 선, 다각형**을 말하며, **영상 기본 요소**는 **2D 비트맵 영상**을 말한다.

OpenGL의 출력은 **입력된 기하 기본 요소로 구성된 물체를 렌더링한 모습**으로, 필요 시 **입력된 영상 기본 요소가 렌더링에 반영**된다.

</br>

파이프라인 구조는 **그래픽 처리 작업을 기능 별로 세분하여 이를 순차적으로 배치**한 것이다.

이러한 분업의 장점은 **전체적인 처리 속도 향상**에 있다. 즉, 유휴 시간을 줄여 새로운 입력을 받을 수 있다.

</br>

![제목 없는 다이어그램 drawio (4)](https://github.com/user-attachments/assets/d212bb55-0923-4316-8be4-6dc6978e7ce0)

</br>

파이프라인은 크게 위 그림과 같은 **서브 프로세서**로 이루어져 있다.

입력 기본 요소에 변환, 투상, 절단, 래스터 등의 **프로세싱이 순차적으로** 이루어진다. 일반적으로 **서브 프로세싱은 모두 하드웨어에 의해 구현**된다.

결국 **파이프라인 구조에 의해 동시 작업이 이루어진다**는 점, **서브 프로세싱이 하드웨어로 구현된다**는 점으로 인해 그래픽 처리 속도가 빨라진다.

</br>

![제목 없는 다이어그램 drawio (6)](https://github.com/user-attachments/assets/323de1ce-bc16-41f2-8491-2972c042f4ed)

</br>

OpenGL은 하드웨어적으로 고정된 **파이프라인 처리 순서를 변경할 수 없다**.

OpenGL은 단지 **서브 프로세서에 매개변수를 전달**하는 일을 한다. OpenGL은 거대한 상태 변수 기계(SVM)다.

**상태 변수**는 **물체가 어떻게 그려져야 할 것인지를 표현하는 변수**들을 말하며, **그래픽 컨텍스트**라고도 불린다.

</br>

위의 그림에서 보이듯이 **개별 프로세서는 상태 변수의 값을 기준으로 실행**된다.

결국 **OpenGL 프로그램은 입력과 입력에 가해질 프로세스의 상태 변수 값을 명시하는 것**에 불과하다.

OpenGL 프로그램의 실행 과정을 의사 코드로 표현하면 다음과 같다.

</br>

```
for Each Primitive                                              # 정의된 각각의 기본 요소에 대해
{
    Update OpenGL States;                                       # 상태 변수를 설정하고
    Render the Primitive according to Pipeline Processing;      # 파이프라인을 실행한다.
}
```
</br>

**기본 요소에 한꺼번에 여러 속성을 적용**하기 위한 방법 중 하나는 **명령어에 파라미터 리스트를 부가**하는 것이다.

예를 들어, drawLine((1, 0), (3, 0), 3, 4, (255, 0, 0))이라는 명령어를 살펴보자.

좌표 (1, 0), (3, 0)을 연결하는 선을 그리되, 점선(3)으로 설정하고 선의 두께는 4배 크기로, RGB 속성 중 빨간색으로 그리라는 의미다.

위의 명령어와 동일한 스타일, 두께, 색상을 지닌 3개의 선을 그리려면 다음과 같은 명령을 작성할 수 있다.

</br>

```
drawLine((1, 0), (3, 0), 3, 4, (255, 0, 0));
drawLine((3, 0), (2, 5), 3, 4, (255, 0, 0));
drawLine((2, 5), (1, 0), 3, 4, (255, 0, 0));
```
</br>

이렇게 되면 명령어를 사용할 때마다 **해당 기본 요소가 지닌 모든 속성 값들을 반복해서 나열**해야 한다.

속성 하나만 변하고 나머지 모든 속성은 그대로 있더라도 매개변수 리스트에 이를 또 다시 작성해야 하는 불편함이 있다.

</br>

ISO 표준은 이런 불편을 해소하기 위해 **시스템 테이블**을 권장한다.

시스템 테이블에는 **현재 지정된 모든 속성 값들과 테이블의 속성 값을 검색하는 변경시키는 함수가 존재**한다.

</br>

이렇게 하면 **명령어에 동일한 파라미터 값을 반복할 필요가 없다**.

명령어가 호출되면 그 즉시 현재 설정된 스타일, 두께, 색상 값을 **시스템 테이블에서 찾아 자동으로 적용**하기 때문이다.

물론 프로그램 시작 시에는 시스템 테이블에 **기본 값들이 저장되어 있고, 속성 변경이 없으면 이들이 사용**된다.

</br>

```
setLineStyle(2);
setLineWidth(4);
setLineColor(255, 0, 0);

drawLine((1, 0), (3, 0));
drawLine((3, 0), (2, 5));
drawLine((2, 5), (1, 0));
```
</br>

시스템 테이블을 사용하면 **어떤 기본 요소를 그리든지 항상 테이블에 기록된 현재의 속성 값이 적용**된다.

실제 예시로 2D 그래픽 편집기인 일종의 그림판의 UI에도 이러한 개념이 적용된다.

</br>

</br>

OpenGL의 **상태 변수**는 ISO 표준에서 말하는 속성에 해당한다. 또 OpenGL의 **상태 테이블**은 ISO 표준의 시스템 테이블에 해당한다.

즉, OpenGL에서 상태 변수 값을 설정하면, 상태 테이블에 기록되고, **개별 프로세서는 필요한 상태 변수 값을 이 테이블로부터 읽어 프로세스를 실행**하게 된다.

</br>

**상태 변수는 변수명에 의해 구별**된다. 예를 들어 현재 색상이라는 상태 변수는 CL_CURRENT_COLOR라는 변수명으로 나타낸다.

상태 변수에는 **새로운 값을 설정**(Setting)하거나 **현재 값을 검색**(Query)하는 두 종류의 함수가 있다.

</br>

```
glColor3f(1.0, 1.0, 1.0);
```
</br>

위 함수는 GL_CURRENT_COLOR 상태 변수 값을 (1.0, 1.0, 1.0)으로 설정한다. 이는 **RGB 값을 설정**하는 함수로 결과적으로 하얀색으로 설정된다.

이렇게 설정된 **상태 변수 값은 이후 또 다른 명령에 의해 그 값이 바뀔 때까지 유효**하다.

</br>

```
float my_color[3];                              # 임의 배열
glGetFloatv(GL_CURRENT_COLOR, my_color);        # 상태 값 검색 함수
```
</br>

glGet* 함수는 검색 함수다. 즉, **어떤 상태 변수의 현재 값을 알기 위한 함수**다.

위 함수에서 첫 번째 매개변수인 CL_CURRENT_COLOR가 검색하고자 하는 상태 변수다. 겸색 결과 리턴 값은 그 다음 매개변수인 my_color에 저장된다.

따라서 함수 실행 결과 my_color[0], my_color[1], my_color[2]에는 현재 색상의 R, G, B 값이 각각 기록된다.

상태 변수는 다양한 타입일 수도 있으므로 타입별 검색을 위해서는 다음과 같은 함수 프로토타입을 사용한다.

</br>

```
void GetIntegerv (enum state_name, int* data);
void GetFloatv (enum state_name, float* data);
void GetPointerv (enum state_name, double* data);
void GetBooleanv (enum state_name, boolean* data);
```
</br>

검색 결과를 data[]에 리턴한다고 간주하면, 괄호 내부의 *data는 그 배열을 가리키는 포인터다.

C에서는 배열명 그 자체가 포인터므로, 단순히 배열명을 매개변수로 전달하면 된다.

</br>

상태 변수를 설정하는 또 다른 함수 몇 가지를 보자.

</br>

```
glPointSize(0.5);               # 1
glLineWidth(5);                 # 2
glShadeModel(GL_SMOOTH);        # 3
```
</br>

#1은 점 크기를 나타내는 상태 변수 값을 0.5로 설정하라는 것이며, #2는 선 두께의 상태 변수 값을 5로 설정하라는 것이다.

#3의 **glShadeModel()**은 **어떤 다각형 내부에 색을 칠하는 방식을 결정하는 함수**로, 이 함수에 영향을 받는 **상태 변수가 GL_SHADE_MODEL**이다.

매개변수가 **GL_SMOOTH**여서 마치 상태 변수명처럼 보이지만 실은 변수명이 아닌 **GL_SHADE_MODEL 변수의 enum 값 중 하나**다.

</br>

상태 변수를 정하는 함수에서는 **함수명을 보고 대략적으로 어떤 상태 변수가 영향을 받는지 짐작**할 수 있다.

그러나 구체적으로 그 **상태 변수명이 어떤 것인지는 잘 드러나지 않는다**.

**설정된 값을 검색하기 위해서는** 위 CL_CURRENT_COLOR처럼 반드시 **구체적인 상태 변수명을 알아야만** 한다.

</br>

어떤 상태 변수는 속성이 아니라 **기능**에 속한다. 이런 상태 변수는 속성 값이 아니라 해당 **기능에 대한 활성화/비활성화 모드**가 관건이다.

조명, 텍스처 등과 같은 종류의 상태 변수를 **모드**라고 한다. 모드는 일반적인 상태 변수보다 **좀 더 포괄적인 개념**의 상태 변수다.

모드를 처리하기 위해서는 설정, 해제, 검색 등 세 종류의 함수가 필요하다.

</br>

```
glEnable(GL_LIGHTING);              # 조명 모드를 활성화
if glIsEnabled(GL_LIGHTING)         # 현재 조명 모드가 활성화되어 있으면
    glDisable(GL_LIGHTING);         # 조명 모드를 비활성화
```
</br>

모드를 활성화하려면 glEnable()을, 비활성화하려면 glDisable()을 사용한다.

어떤 모드가 현재 활성화되어 있는지를 확인하기 위해서는 glIsEnabled()를 사용한다. 

매개변수는 확인하려는 모드명이고, 함수 실행 결과는 Boolean인 TRUE/FALSE로 리턴된다.

</br>

```
void glEnable(enum mode_name);
void glDisable(enum mode_name);
boolean glIsEnabled(enum mode_name);
```
</br>