## OpenGL 개괄

</br>
</br>

### 4.3.1 API 레벨

</br>

</br>

위의 그림은 표준 및 API의 발전 과정을 나타낸다.

</br>

3D 그래픽 프로그램과 개인용 컴퓨터를 이용하여 3D 응용프로그램을 개발할 수 있게 되었다.

개발자의 입장에서는 **프로그램을 얼마나 수월하게 작성할 수 있는가**가 가장 큰 관건이며, API는 이를 위해 존재한다.

**API**는 프로그래밍 언어가 아닌 **프로그래밍 언어를 사용하여 작성된 라이브러리 함수**다.

따라서 개발자는 API를 이용하여 원하는 그래픽 프로그램을 작성할 수 있다.

</br>

3D API 시장을 오랫동안 주도해 온 사실 표준은 OpenGL이다. API 수준에서 **OpenGL은 저수준 API**다.

따라서 OpenGL은 **묘사된 내용으로부터 그 장면을 그려내기 위해 필요한 구체적인 프로시저**에 해당한다.

이런 점에서 OpenGL은 OpenInventer, VRML, Java3D 등 **고수준 인터페이스의 기반**이 된다.

즉, 고수준 인터페이스도 결국 **OpenGL 인터페이스 함수를 내부적으로 호출**하여 프로그램을 실행한다.

</br>

OpenGL과 마찬가지로 저수준 API에 속하는 것이 **Direct 3D**다.

이는 Microsoft의 DirectX 미디어 라이브러리의 일부로, **게임 프로그램에 주로 사용**되며 상대적으로 **매우 복잡한 API**에 속한다.

Direct 3D는 **DirectDraw 라이브러리 함수를 바탕으로 구성된 라이브러리**로 작성을 위해서는 DirectDraw 라이브러리를 알아야만 했다.

Direct 3D의 가장 큰 단점은 **Microsoft Windows 계열**에서만 돌아간다. 즉, **호환성이 없다**는 점이다.

</br>

개발자의 입장에서는 고수준 API가 저수준 API보다 사용하기 용이하다. 그러나 문제는 간단하지 않다.

일반적으로 **설계가 너무 추상적으로 진행되면 구체적인 내용을 변경할 수 없다**.

</br>

OpenGL의 장점은 이것이다. 고수준 API에서는 추상적인 함수만을 허용해서 세부적으로 그 함수 내부의 명령이나 변수의 일부를 변경할 수 없다.

OpenGL은 그래픽 메모리, 그래픽 가속 칩 등의 **하드웨어와 매우 근접**하여 이들을 **직접 제어**하여 하드웨어 **성능을 최대한 발휘**시킬 수 있다.

</br>

</br>

위의 그림은 OpenInventor를 예로 들어 OpenGL의 상대적인 위치를 나타낸 그림이다.

장면 묘사를 허용하는 고수준 API인 OpenInventor는 **결국 저수준 API인 OpenGL로 변환**된다. 

그러나 **OpenGL 역시 하드웨어를 직접 제어하지는 않는다**. 개발자가 하드웨어를 일일히 제어하는 것은 어렵다.

OpenGL도 드라이버 소프트웨어에 비해서는 상대적으로 고수준 함수여서, 결국은 **디바이스 드라이버를 통해 하드웨어 제어 명령으로 번역**된다.

</br>

**모든 3차원 물체 표면은 평면 삼각형의 집합으로 근사**시킬 수 있다.

그래픽 처리는 **기본 요소를 정의하고 조합하여 복잡한 물체를 설계**하는 **모델링** 작업과 **모델링된 물체를 화면에 그려내는 렌더링** 작업으로 나눌 수 있다.

</br>

고수준 API에서는 모델링에 치중하지만 저수준 API인 **OpenGL은 렌더링에 치중**한다.

OpenGL은 저수준 API이기 때문에 점, 선, 다각형 수준의 **기본 요소만을 이해**한다.

따라서 OpenGL에서는 고수준 API처럼 물체를 원구, 원기둥 등의 차원에서 정의할 수 없다.

정리하면 물체가 단순하든, 복잡하든 **이미 설계된 물체를 화면에 그려내기 위한 것이 OpenGL**이다.

</br>

같은 저수준 API인 DirectX에 비해 OpenGL이 사실 표준으로 인정받는 이유는 **너무 많은 것을 하려고 하지 않기 때문**이다.

OpenGL은 물체를 설계하거나, 윈도우를 조작하거나, 세련된 애니메이션을 가하거나, 소리를 추가하는 작업 등을 할 수 없다. **단지 이미 설계된 물체를 그려낼 뿐**이다.

하지만 **렌더링에 관련된 작업에서의 OpenGL은 다양하고 유용한 기능을 고속으로 처리**한다.

</br>

OpenGL에서 Open이 의미하는 바와 같이 **GL의 소스는 공개**되어 있다. 이는 GL 시장이 확장되길 바라는 SGI 사의 방침이다.

</br>
</br>

### 4.3.2 OpenGL의 설계 원리

</br>

**OpenGL은 C 또는 어셈블리어로 작성**된 약 200여 개의 함수로 구현되어 있다.

C뿐만 아니라 **C++, Ada, FORTRAN, Java도 OpenGL API를 호출하여 사용**할 수 있다.

OpenGL 개발에 있어서 고려된 설계 원리를 몇 가지로 요약해보자.

</br>

* 범용성
    + OpenGL은 거의 **대부분의 하드웨어에서 실행**될 수 있도록 설계되었다.
    + OpenGL은 소프트웨어적인 측면에서 **운영체제와 무관**하게 설계되었다.

* 효율성
    + OpenGL은 주어진 기능을 프로그램에 의해 활성화/비활성화 할 수 있도록 **기능 모드를 제공**한다.

* 독립성
    + 어떤 기능을 활성화/비활성화 모드로 변경하는 행위가 다른 기능에 영향을 미쳐서는 안된다.
    + **기능끼리 서로 얽혀 발생하는 오류를 방지**한다.

* 완전성
    + OpenGL은 **특정 하드웨어 기능에 대해서는 ARB 확장 형태로 명령어를 제공**함으로써 그래픽 하드웨어 성능을 최대로 발휘한다.
    + 다수의 하드웨어가 확장 기능을 지원한다면 그 기능을 OpenGL의 표준 기능으로 변경된다.
    + 특정한 하드웨어만 확장 기능을 지원한다면 **이식성이 저해**된다.

* 상호작업성
    + OpenGL은 **Client-Server 모델을 사용**하여 상대적으로 성능이 낮은 클라이언트 컴퓨터가 고성능 서버를 이용할 수 있다.

</br>
</br>

### 4.3.3 파이프라인과 상태 변수

</br>

CPU의 처리 속도를 개선한 것이 파이프라인이듯, 그래픽 보드 내부의 **GPU의 처리 속도를 개선**한 것이 **파이프라인** 구조다.

</br>

</br>

**OpenGL의 입력은 기하 기본 요소와 영상 기본 요소로 구성**된다.

**기하 기본 요소**는 **3D의 점, 선, 다각형**을 말하며, **영상 기본 요소**는 **2D 비트맵 영상**을 말한다.

OpenGL의 출력은 **입력된 기하 기본 요소로 구성된 물체를 렌더링한 모습**으로, 필요 시 **입력된 영상 기본 요소가 렌더링에 반영**된다.

</br>

파이프라인 구조는 **그래픽 처리 작업을 기능 별로 세분하여 이를 순차적으로 배치**한 것이다.

이러한 분업의 장점은 **전체적인 처리 속도 향상**에 있다. 즉, 유휴 시간을 줄여 새로운 입력을 받을 수 있다.

</br>

</br>

파이프라인은 크게 위 그림과 같은 **서브 프로세서**로 이루어져 있다.

입력 기본 요소에 변환, 투상, 절단, 래스터 등의 **프로세싱이 순차적으로** 이루어진다. 일반적으로 **서브 프로세싱은 모두 하드웨어에 의해 구현**된다.

결국 **파이프라인 구조에 의해 동시 작업이 이루어진다**는 점, **서브 프로세싱이 하드웨어로 구현된다**는 점으로 인해 그래픽 처리 속도가 빨라진다.

</br>

OpenGL은 하드웨어적으로 고정된 **파이프라인 처리 순서를 변경할 수 없다**.

OpenGL은 단지 **서브 프로세서에 매개변수를 전달**하는 일을 한다. OpenGL은 거대한 상태 변수 기계(SVM)다.

**상태 변수**는 **물체가 어떻게 그려져야 할 것인지를 표현하는 변수**들을 말하며, **그래픽 컨텍스트**라고도 불린다.

</br>

위의 그림에서 보이듯이 **개별 프로세서는 상태 변수의 값을 기준으로 실행**된다.

결국 **OpenGL 프로그램은 입력과 입력에 가해질 프로세스의 상태 변수 값을 명시하는 것**에 불과하다.

OpenGL 프로그램의 실행 과정을 의사 코드로 표현하면 다음과 같다.

</br>

```
for Each Primitive                                              # 정의된 각각의 기본 요소에 대해
{
    Update OpenGL States;                                       # 상태 변수를 설정하고
    Render the Primitive according to Pipeline Processing;      # 파이프라인을 실행한다.
}
```
</br>