## API

</br>
</br>

### 4.2.1 그래픽 API

</br>

**API**(응용 프로그램 인터페이스)는 **함수를 사용하여 프로그램을 작성하는 데 직접 활용할 수 있도록 한 것**이다.

이 라이브러리는 개념적으로 **응용 프로그램과 그래픽 하드웨어 사이에 존재**한다.

여기서 그래픽 하드웨어는 GPU, 그래픽 메모리 등 그래픽 카드 상의 하드웨어를 비롯한 **그래픽 처리에 관여하는 일체의 하드웨어**를 말한다.

</br>

</br>

그래픽 라이브러리로 직접 하드웨어를 제어하는 명령 대신 상위 개념인 **라이브러리 함수를 호출함으로써 손쉽게 응용프로그램을 작성**할 수 있다.

응용프로그램이 **그래픽 라이브러리 함수를 호출**하면, **드라이버 소프트웨어에 의해** 해당 하드웨어를 제어하는 **어셈블리 명령으로 변환**된다.

</br>

**PDL**(Page Description Language)은 **2D 그래픽 API**로, **텍스트와 2D 그래픽을 포함한 문서를 서술하는 함수**다.

구체적으로 이 함수는 **텍스트나 그래픽을 렌더링하기 위한** 것들이다.

이를 활용하면 문서 이미지를 교환하는 대신 PDL 명령어만을 교환함으로써 문서의 송수신이 간편해진다.

</br>

X는 유닉스 워크스테이션의 2D 그래픽 API로, X 윈도우에서 텍스트나 그래픽을 그리기 위한 함수다. X의 장점은 **네트워크 활용**에 있다. 

프로그램이 어떤 워크스테이션에서 돌아갈 때, 디스플레이는 다른 곳을 향하게 하고, 사용자 입력은 또 다른 워크스테이션에서 받아들이게 한다.

</br>

3D 그래픽 API로는 PEX나 Renderman이 있다. 

**PEX**는 **PHIGS에 기반**을 두고 **X를 확장**한 것이지만, X 윈도우 상에서만 돌아가서 **범용성 확보가 어렵다**.

PIXAR에서 제작한 **Renderman**은 **다양한 물체의 모습을 상대적으로 정확하게 서술**할 수 있다.

하지만 Renderman은 **그래픽 보드의 가속 기능을 제대로 활용하기 어려워서** 빠른 상호작용을 기대하는 그래픽에는 거의 사용되지 않는다.

</br>

3D 그래픽 API는 라이브러리 함수의 구체성을 기준으로 두 가지로 분류한다

**고수준 API**에서는 **그림을 그리기 위한 실제적인 세부 과정을 명시**하는 대신, 물체를 정의하고 물체 사이의 관계를 묘사함으로써 프로그램 작성이 완료된다.

**저수준 API**에서는 물체를 구성하는 **기본 요소의 정의부터 실제 그림을 그리는 세부적인 과정에 이르기까지 일일히 명시**해야 한다.

고수준 API에는 OpenInventor, VRML, Java3D 등이 있고, **저수준 API에는 OpenGL, Direct3D** 등이 있다.

</br>
</br>

### 4.2.2 고수준 API

</br>

임의의 언어를 사용하여 카메라 위치에서 바라본 장면을 그려내기 위해 가상 고수준 API 언어를 사용하여 장면 묘사 프로그램을 작성해보자.

</br>

```
Camera
{
    center              { 0.0, 0.0, 5.0 }                       // 카메라 중심을 (0.0, 0.0, 5.0)에 위치하게 설정
    direction           { 0.0, 0.0, -1.0 }                      // 카메라가 (0.0, 0.0, -1.0)을 바라보게 설정
}

Lights
{
    numLights           1                                       // 광원의 개수를 1개로 설정
    DirectionalLight    {                                       // 방향성 광원으로 설정하고
                            direction   { 0.5, 0.5, 0.5 }       // (0.5, 0.5, 0.5) 방향으로 빛을 비추되
                            color       { 1.0, 1.0, 1.0 }       // 광원이 백색 빛을 내도록 설정 
                        }
}

Background
{
    color               { 1.0, 1.0, 1.0 }                       // 배경색을 백색으로 설정
}

Group
{
    numObject           2                                       // 물체 2개로 이루어진 그룹
    Material            { 0.0, 0.0, 1.0 }                       // 첫 물체의 색상을 파란색으로 설정하고
    Sphere              { 2.0 }                                 // 반지름이 2인 원구를 그림
    Transform           {
                            Translate   { 1.0, 0.0, 0.0 }       // x축 방향으로 1.0만큼 이동하여
                            Scale       { 0.3, 0.3, 0.3 }       // 크기를 x, y, z축을 0.3배 축소시킨
                            Material    { 1.0, 0.0, 0.0 }       // 색상이 빨간색인
                            Sphere      { 2.0 }                 // 반지름이 2인 원구를 그림
                        }
}
```
</br>

괄호 내부의 파라미터 값은 일반적으로 점의 좌표, 색상, 벡터 등을 의미한다. Sphere 명령 다음의 파라미터는 그리고자 하는 원구의 반지름을 의미한다.

여기서는 이러한 구체적인 값들을 무시하고 프로그램의 일반적인 형태에 주목해야 한다.

</br>

**Camera** 명령은 장면을 포착하기 위한 카메라 위치를 설정한다. 여기서 **카메라 중심의 위치와 카메라가 바라보는 방향을 명시**하고 있다.

**Light** 명령은 **조명에 관한 것**으로, **광원의 개수**는 1개, 모든 빛이 한쪽 방향으로만 진행하는 방향성 **광원**, **색상**은 백색임을 나타낸다.

**Background** 명령은 **배경 색상**을 백색으로 설정하기 위함이다.

</br>

**Group** 명령은 **2개 이상의 물체를 묶어 하나로 취급**하기 위한 것이다. 위의 예제에서는 2개의 원구를 하나로 그룹화했다.

Material 명령은 물체의 색상이나 재질 등의 속성을 지정하는 명령으로, 여기서는 물체의 색을 지정한다.

</br>

오른쪽 원구를 그리기 위해서는 왼쪽 원구 위치에서부터 이동시켜야 한다.

현재 크기 조절 인수는 (x, y, z) 방향이자 기본값인 (1.0, 1.0, 1.0)으로 되어있으므로 이를 (0.3, 0.3, 0.3)으로 변경한다.

**이동, 크기 조절은 일종의 변환**이므로, 오른쪽 원구는 **변환을 의미하는 Transform 명령 내부에 선언**되고 있다.

</br>

</br>

위 프로그램은 사실상 위의 그림과 같은 계층 구조를 내포하고 있다.

**장면의 요소를 계층 구조로 조직화하여 나타낸 트리**를 **장면 그래프**라고 한다.

**그룹 노드**는 그 아래에 또 다른 그룹 노드를 거느릴 수 있으므로 **중첩 구조를 형성할 수 있다**.

위의 그림에서는 변환 작업을 별도의 노드로 취급함으로써 그 아래에 중첩된 모든 하위 노드는 자동으로 해당 변환이 가해져야 할 대상임을 나타낸다.

이렇게 되면 **하나의 장면을 그려내기 위해 트리를 관통**하기만 하면 된다.

</br>

이처럼 **장면 묘사를 위주로 하는 고수준 API**로는 OpenInventer가 있다.

객체지향적인 C++ 라이브러리 함수 호출로 구성된 OpenInventer는 실제로 다시 **이보다 저수준 API인 OpenGL 함수를 다시 호출하여 실행**된다.

OpenInventer에서 사용된 **장면 그래프 개념은 VRML과 Java3D 등에 그대로 적용**된다.