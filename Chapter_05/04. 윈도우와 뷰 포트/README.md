## 윈도우와 뷰 포트

</br>
</br>

### 5.4.1 정규 좌표와 화면 좌표

</br>

GL 프로그램이 실행되면서 입력 기본 요소인 정점에 일련의 변환이 가해진다. 이 변환을 대변하는 것이 좌표계다.

즉, 파이프라인 변환 프로세스를 거치면서 기준 좌표계가 변경되고, 그때마다 정점 좌표가 새로운 좌표계 기준으로 바뀐다.

</br>

![제목 없는 다이어그램 drawio (2)](https://github.com/user-attachments/assets/4f6d1383-ea68-42a3-9493-e72332a55150)

</br>

|좌표계|설명|
|-----|----|
|모델 좌표계|물체별로 모델링에 편하게 설정된 좌표계|
|전역 좌표계|개별 물체를 모았을 때 이를 한번에 아우르는 좌표계|
|시점 좌표계|물체를 바라보는 시점을 기준으로 표현한 좌표계|
|절단 좌표계|시점으로부터 보이지 않는 물체를 잘라내기 편하게 설정한 좌표계|

</br>

좌표계에 대해서는 나중에 알아보기로 하고, 좌표 처리의 마지막인 **정규 좌표계와 화면 좌표계**에 대해 알아보자.

바로 이 부분이 **최종적으로 그림을 화면에 뿌리는, 즉 GLUT의 윈도우 기능을 관여**하는 단계다.

</br>

모든 3D 물체는 렌더링 결과 2D 화면에 뿌려져야 한다. 즉, **어느 순간에 3D 좌표에서 2D 좌표로의 변환이 필요**하다.

이 변환은 **절단 좌표계에서 정규 좌표계로 넘어오면서** 이루어진다. 여기서 **정규 좌표(NDC)**는 **1을 기준으로 하는 2D 좌표**다.

</br>

![제목 없는 다이어그램 drawio (3)](https://github.com/user-attachments/assets/937f4001-0f0c-4f90-b76b-c969b43c010c)

</br>

**정규화**는 **어떤 값을 1을 기준으로 하여 상대적으로 표시하는 행위**다. 

따라서 **정규화를 거치면 모든 정점 좌표는 1보다 작은 값으로** 바뀐다.

정규 좌표계의 **원점은 화면의 정중앙에 위치**하며, **우측으로 +x, 상단으로 +y로 증가**한다. 

이렇게 되면 우상단 좌표는 (1.0, 1.0), 좌하단 좌표는 (-1.0, -1.0)이 된다.

</br>

화면 좌표계(SCS)는 장치 좌표계(DCS), 윈도우 좌표계(WCS)라고 부르는데, 화소 단위로 좌표를 표시한다.

예를 들어 해상도 1024×768인 화면이라면 x값은 0~1023, y값은 0~767에 분포한다.

</br>

일반적인 **Windows의 화면 좌표계**는 **화면의 좌상단을 원점으로 하고 우측이 +x, 하단이 +y로 진행**한다.

그러나 이러한 좌표계 설정은 상대적인 것이므로 소프트웨어나 컴파일러 등에 따라 달라질 수도 있다.

</br>

소수 정밀도를 지닌 정규 좌표는 정수 정밀도의 화면 좌표로 바뀐다.

정규 좌표 (0.5, 0.5)를 해상도 1024×768인 일반적인 Windows 운영체제의 화면 좌표계로 변환해보자.

정규 좌표의 x가 -1.0에서 +1.0으로 진행할 때, 화면의 x 좌표는 0에서 1023까지 진행한다.

따라서 비례식을 이용하면 **x = 1023 × (0.5 - (-1.0)) / 2.0 = 767.25 ≒ 767**이 된다.

정규 좌표의 y가 1.0에서 -1.0으로 진행할 때, 화면의 y 좌표는 0에서 767까지 진행된다.

따라서 비례식을 이용하면 **y = 767 × (0.5 - (1.0)) / -2.0 = 191.75 ≒ 192**가 된다.

</br>

정규 좌표를 사용하면 해상도에 따른 화면 좌표 계산이 단순화된다.

예를 들어, 화면의 x 좌표를 계산하는 위의 과정을 줄이면 **1023 × ((정규 좌표) + 1.0) × 0.5**가 된다.

따라서 **일단 ((정규 좌표) + 1.0) × 0.5 부분이 계산**되면, 이후 여기에 원하는 **화면 해상도를 곱해주기만 하면 정규 좌표계에서 화면 좌표계로 변환**된다.

절단 좌표계로부터 직접 화면 좌표계를 계산할 수도 있지만 반드시 정규 좌표계를 거치는 이유가 이것 때문이다.

<br>

----------------------------------------------------------------------------------

</br>

### 5.4.2 윈도우, 뷰 포트, GLUT 모델링

</br>

![그림_2](https://github.com/user-attachments/assets/9abb864d-df63-45a0-b5de-d76610518a7e)

</br>

**경우에 따라서는 주어진 윈도우의 일부만 사용**하기도 한다. **뷰 포트**는 **윈도우 내부에 설정한 작은 창**을 말한다.

위의 그림은 그래픽 소프트웨어 3D MAX의 화면 인터페이스로, 좌측 윈도우를 4개의 뷰 포트로 분할하여 서로 다른 방향에서 본 물체 모습을 보여준다.

</br>

만약 개발자가 별도로 **뷰 포트를 정의하지 않으면** 기본 설정에 의해 묵시적으로 **현재 윈도우 전체가 하나의 뷰 포트로 간주**된다. 이 경우 **왜곡이 발생하기도** 한다.

예를 들어 사용자가 윈도우의 가로, 세로 길이를 바꿈으로써 뷰 포트 종횡비를 원래의 장면의 종횡비와 달라지게 만들 수도 있다.

이때 뷰 포트는 변경된 가로, 세로 길이에 비례하며 자동으로 장면을 재조정하게 되고, 이에 따라 왜곡이 발생한다.

</br>

여기서 유의할 점은 **원래 씬의 종횡비**에 관한 것이다. 왜곡이 일어나는 이유는 **원래 씬의 종횡비가 그대로 유지되지 않았기 때문**이다.

이에 대한 해결책은 두 가지 정도가 존재한다.

1. 사용자가 윈도우 크기를 조절하는 데 있어서 종횡비를 원래 씬의 종횡비와 반드시 일치하도록 규제

2. 윈도우 내부에 별도의 뷰 포트를 열되, 이 뷰 포트의 종횡비가 원래 장면의 종횡비와 반드시 일치하도록 코딩

</br>

----------------------------------------------------------------------------------

</br>

### 5.4.3 GLUT의 윈도우와 뷰 포트

</br>

앞서 작성했었던 사각형 출력 코드에 생략된 명령어를 추가하여 그 의미를 파악해보기로 하자.

</br>

```C
#include <GL/glut.h>
#include <GL/GL.h>
#include <GL/GLU.h>

void MyDisplay()
{
	glClear(GL_COLOR_BUFFER_BIT);				// #1: GL 상태 변수 설정
    	glViewport(0, 0, 300, 300);
    	glColor3f(1.0, 1.0, 1.0);

	glBegin(GL_POLYGON);					// #2: 입력 기본 요소 정의
	glVertex3f(-0.5, -0.5, 0.0);
	glVertex3f(0.5, -0.5, 0.0);
	glVertex3f(0.5, 0.5, 0.0);
	glVertex3f(-0.5, 0.5, 0.0);
	glEnd();
	glFlush();
}

int main(int argc, char* argv[])
{
	glutInit(&argc, argv);					// #3: GLUT 윈도우 함수
    	glutInitDisplayMode(GLUT_RGB);
    	glutInitWindowSize(300, 300);
    	glutInitWindowPosition(0, 0);
	glutCreateWindow("OpenGL Drawing Example");
    	glClearColor(0.0, 0.0, 0.0, 1.0);
    	glMatrixMode(GL_PROJECTION);				// #4. GL 상태 변수 설정
    	glLoadIdentity();					// #5.
    	glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
	glutDisplayFunc(MyDisplay);
	glutMainLoop();

	return 0;
}
```
</br>

단순해 보이지만 이 프로그램에는 물체를 만들고, 만들어진 물체가 화면 뿌려지기 위해 필요한 거의 모든 요소가 작성되어 있다.

따라서 이 프로그램에 나열된 함수를 제대로 이해하기만 해도 3D 그래픽 요소를 어느 정도 이해했다고 할 수 있다.

</br>

#3의 **glutInit()**은 **GLUT 라이브러리를 초기화**하고 **Windows 운영체제와 연결하여 하나의 세션을 형성**한다.

**glutInitDisplayMode(GLUT_RGB)**는 윈도우의 **기본 컬러 모드를 RGB 모드로 설정**하기 위한 것이다.

**glutInitWindowSize(300, 300)**은 **윈도우의 너비와 높이를 각각 300화소로 설정**하기 위한 것이다.

</br>

**GLUT의 화면 좌표계**는 **운영체제의 화면 좌표계**를 따른다.

**glutInitWindowPosition(0, 0)**은 윈도우의 좌상단을 (0, 0), 즉 **화면 좌표계의 원점에 위치**시키기 위한 것이다.

만약 너비가 400이고, 높이가 300인 윈도우를 화면 좌표 (120, 55)에 위치시키면 그 결과는 아래와 같다.

</br>

![제목 없는 다이어그램 drawio (4)](https://github.com/user-attachments/assets/5746153c-af90-449e-b0e0-63543983f4a1)

</br>

#4의 GL 상태 변수 설정을 보자. 이 부분에서는 **프로그램 전반에 걸쳐 적용되어야 할 GL의 상태 변수가 정의**된다.

수시로 바뀌어야 할 상태 변수는 디스플레이 콜백 함수인 MyDisplay() 내부에 정의하면 된다.

**glClearColor(0.0, 0.0, 0.0, 1.0)**은 **초기화 색이라는 상태 변수의 값을 설정**하는 함수다.

여기서 매개변수의 값은 최소 0.0에서 최대 1.0을 기준으로 명시한 것으로, RGB 빛의 세기가 각각 0.0 최소이므로 이를 합하면 검은색이 된다.

네 번째 매개변수는 알파값으로, 투명도(Opacity)를 나타낸다. 이 값이 1.0이므로 100% 불투명하고 따라서 뒷 배경이 보이지 않는다.

</br>

#1의 GL 상태 변수 설정을 보자. **glClear()**는 GL_COLOR_BUFFER_BIT, 즉 **프레임 버퍼를 초기화**하라는 의미다.

**초기화에 사용될 색은 이전의 glClearColor()에서 설정한 색**이다. 

따라서 현재 초기화 색이 검은색인 상태에서 이 명령을 실행하면 컬러 버퍼의 색은 모두 불투명한 검은색으로 변경된다.

**GL의 컬러 버퍼는 항상 윈도우 내부 화소의 색을 담고 있다**는 것을 감안하면 결국 현재의 모든 윈도우 내부가 모두 검은 배경색으로 칠해진다.

특히, 이 색이 불투명하게 정의되었으므로 윈도우의 뒤 화면색은 전혀 비치지 않게 된다.

</br>

**GL의 뷰 포트는 glViewport(x, y, width, height)에 의해 설정**된다.

예를 들어 glViewport(100, 80, 160, 100)에 의해 생성되는 뷰 포트의 위치와 크기는 아래의 그림과 같다.

여기서 주의할 점은 **GLUT이 사용하는 화면 좌표계와 GL이 사용하는 화면 좌표계가 서로 다르다**는 점이다.

**GLUT은 화면의 좌상단을 원점**으로 하지만, **GL은 윈도우의 좌하단을 원점**으로 한다.

</br>

![제목 없는 다이어그램 drawio (5)](https://github.com/user-attachments/assets/c24c7545-f574-4c84-8ea4-44cd0b2a0496)

</br>

GL 화면 좌표계는 **윈도우 좌하단 원점을 중심으로 우측으로 +x, 상단으로 +y 축이 진행**된다.

이는 수학에서 배우는 2차원 좌표축의 방향과 같으며, GL의 의도 역시 이와 비슷하다.

</br>

위 코드에서 glViewport(0, 0, 300, 300)으로 선언함으로써 원래 glutInitWindowSize(300, 300)에 의해 설정된 윈도우 전체를 하나의 뷰 포트로 만든다.

**화면에 보이는 물체는 향상 현재 뷰 포트의 종횡비의 비례하여 축소 또는 확대**된다.

</br>

만약 glViewport()로 뷰 포트를 **별도로 설정하지 않으면 뷰 포트는 항상 자동적으로 현재 윈도우와 일치**하게 된다.

따라서 프로그램이 시작하는 순간의 뷰 포트는 **gluInitWindowSize()에 의해 설정된 윈도우와 일치**한다.

하지만 프로그램 실행 중 사용자가 **윈도우 크기를 변경하면 그 즉시 뷰 포트는 변경된 윈도우와 일치**하게 된다.

</br>

----------------------------------------------------------------------------------

</br>

### 5.4.4 GLUT 모델링

</br>

사용자의 편의를 위해 GLUT은 이미 모델링된 물체를 몇 가지 제공한다.

정육면체, 원구, 원환체, 원뿔, 정사면체, 정팔면체, 정십이면체, 정이십면체, 차 주전자 등이 있다.

</br>

#### 정육면체

```C
// Solid: 물체 겉면이 칠해진 형태
// Wire: 물체 뼈대만 선으로 표시한 형태

void glutSolidCube(GLdouble size);      // size: 한 변의 길이
void glutWireCube(GLdouble size);
```
</br>

#### 원구

```C
void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);      // radius: 원구의 반지름
void glutWireSphere(GLdouble radius, GLint slices, GLint stacks);       // slices: 경선의 수, stacks: 위선의 수
```
</br>

#### 원환체

```C
void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings);     // innerRadius, outerRadius: 원환체 안쪽과 바깥쪽의 반지름
void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings);      // nsides: 튜브 단면의 근사 선분의 개수, rings: 튜브 윤곽 선분의 개수
```
</br>

#### 원뿔

```C
void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);     // base: 원뿔 밑면의 반지름, height: 원뿔의 높이
void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);      // slices: z축 둘레를 표시할 선분의 개수, stacks: z축을 따라서 근사화할 면의 개수
```
</br>

#### 정이십면체

```C
void glutSolidIcosahedron(void);        // 모델 좌표계 원점을 중심으로 반지름 1.0인 정이십면체를 그림
void glutWireIcosahedron(void);
```
</br>

#### 차 주전자

```C
void glutSolidTeapot(GLdouble size);
void glutWireTeapot(GLdouble size);
```
</br>
