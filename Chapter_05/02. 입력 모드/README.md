## 입력 모드

</br>

입력 장치와 응용프로그램 사이에 **어떤 방법으로 상호작용이 일어나는지에 따라 입력 모드를 구분**한다.

입력 모드 이전에 메저(Measure)와 트리거(Trigger)를 구분할 필요가 있다.

</br>

**메저**는 **입력 장치가 응용프로그램에 넘겨주는 값**이다. **트리거**는 **메저를 가져가라는 신호**다.

예를 들어 문자열을 입력받는 문자열 입력 장치에서 사용자가 DIR을 치고 엔터 키를 눌렀다고 하면 메저는 DIR이고 엔터 키는 트리거다.

</br>

트리거에 의해 **메저가 응용프로그램에 전달된다는 것은 메저가 이미 저장되어 있음을 전제**로 한다.

**메저 프로세스**는 **메저를 인식하여 저장하는 과정**으로 일반적으로 **장치를 초기화할 때 실행**되기 시작한다.

메저 프로세스와 트리거의 관계를 기준으로 **입력 모드를 세 가지로 구분**할 수 있다.

</br>
</br>

### 5.2.1 리퀘스트 모드

</br>

**리퀘스트 모드**는 **프로그램이 실행 중에 메저를 요구하는 방식**이다. 구체적으로 프로그램이 메저 프로세스에 값을 요구한다.

이 경우 메저 프로세스는 자신이 인식한 메저 값을 프로그램에 전달한다. 이 전달은 **트리거 신호가 프로세서로부터 전달되는 순간에** 이루어진다.

리퀘스트 모드를 적용하기 위해서는 일반적으로 다음 명령어를 사용한다.

</br>

```
Request_Locator (Device_ID, &Measure);
```
</br>

이 명령어는 리퀘스트 모드를 사용하여 논리적 입력 장치인 좌표 입력기로부터 메저를 가져오고 그 값을 메저 변수에 저장하라는 의미다.

여기서 **Device_ID**는 **물리적 장치의 아이디**를 말한다. **Device_ID 값만 변경하면 물리적 입력 장치를 자유롭게 변경**할 수 있다.

즉, **논리적 장치와 물리적 장치를 분리함**으로써 주어진 논리적 입력 작업에 사용되는 물리적 장치를 쉽게 변경할 수 있다.

</br>
</br>

### 5.2.2 샘플 모드

</br>

**샘플 모드**는 **직접 모드**(immediate Mode)라고도 불린다. 이 방식은 **사용자 트리거가 불필요**하다.

**프로그램이 메저를 요구하면 메저 프로세서는 무조건 현재의 메저를 제공**한다.

따라서 사용자로서는 프로그램의 해당 함수가 실행되기 전에 **이미 필요한 메저 데이터를 입력한 상태여야 한다**.

샘플 모드를 적용하기 위해서는 일반적으로 다음과 같은 명령어를 사용한다.

<br>

```
Sample_Locator (Device_ID, &Measure);
```
</br>
</br>

### 5.2.3 리퀘스트 모드와 샘플 모드의 비교

</br>

메뉴 선택 입력기를 기준으로 리퀘스트 모드와 샘플 모드를 비교해보자.

리퀘스트 모드를 사용하는 패키지에서 '회전' 메뉴를 선택하면 프로그램에서 어떤 물체를 회전할 것인지 선택하라고 한다.

사용자가 이에 응답하여 원하는 물체 위로 마우스를 가져가면 메저 프로세스는 일단 해당 물체의 아이디를 인식한다.

이 상태에서 마우스를 누르는 순간, 메저가 프로그램에 전달된다.

</br>

반면 샘플 모드에서는 회전될 물체를 미리 마우스로 눌러 선택한다.

이후 '회전' 메뉴를 선택하면 프로그램이 자동으로 이미 저장되어 있는 메저를 가져온다.

</br>
</br>

### 5.2.4 이벤트 모드

</br>

리퀘스트 모드나 샘플 모드에서는 프로그램이 Device_ID로 지정한 물리적 장치 이외에 어떤 입력 장치로부터의 입력도 무시된다.

사용자로서는 **프로그램이 실행 중에 요구하는 장치에서만 입력할 수 있다**는 것이다. 이러한 논리는 문제가 된다.

프로그램은 사용자가 어떠한 입력 장치를 사용할지 모르는 상태에서, **사용자가 원하는 입력 장치 및 데이터를 기준으로 대응해야 한다**.

</br>

**이벤트 모드**에서는 **사용자가 선택한 입력 장치가 우선권**을 가진다.

이는 프로그램이 실행되다가 어느 순간에 입력 장치를 지정해서 사용자에게 데이터 입력을 요구하는 것이 아니다.

아무 때나 사용자가 임의로 선택한 입력 장치를 사용하여 입력 데이터를 프로그램에 전달할 수 있고, **프로그램은 이에 맞추어 해당 작업을 수행**해야 한다.

이 경우 **입력 장치가 트리거되는 순간 하나의 이벤트가 발생한 것으로 간주**한다.

</br>

**이벤트가 발생**하면 **메저가 해당 입력 장치의 아이디와 함께 프로그램에 전달**되어야 한다.

그러나 입력 장치별로 여러 개의 이벤트가 발생하기 때문에 **발생한 순서대로 순차적으로 처리**해야 하는데 여기에 **이벤트 큐**(Event Queue)를 사용한다.

</br>

**이벤트 모드를 사용하는 시스템**을 **이벤트 구동 시스템**이라고 한다.

각 입력 장치에 이벤트를 발생시키면 **발생 순서대로 이벤트 레코드가 이벤트 큐에 삽입**된다.

이벤트 레코드는 **이벤트 타입, 이벤트를 발생시킨 물리적 장치의 아이디, 메저 등으로 구성**된다.

</br>

**응용프로그램은 주기적으로 이벤트 큐를 검사**한다. 이는 **응용프로그램이 드라이버 프로그램에게 이벤트 리퀘스트를 보내는 형식으로 진행**된다.

드라이버는 큐가 비어 있지 않으면 **큐의 맨 앞 레코드를 응용프로그램에게 전달**하고, 큐가 비어 있다면 **새로운 레코드가 삽입될 때까지 대기하거나 다른 일을 수행**한다.

</br>

어떤 장치로부터 이벤트가 발생하여 해당 정보가 이벤트 큐에 삽입되는 과정은 응용프로그램과는 전혀 무관하게 돌아간다.

즉, 응용프로그램이 어떠한 작업을 수행 중이더라도 이와 완전히 동시에 외부 입력 장치로부터 발생한 이벤트 정보는 이벤트 큐에 쌓이게 된다.

</br>

**콜백 함수**는 응용프로그램이 이벤트를 처리하는 방법을 말한다.

이는 **이벤트 처리기**라고도 불리는데, **이벤트 타입별로 프로그램이 수행해야 할 내용을 함수로 나타낸 것**이다.


</br>
</br>

### 5.2.5 게임 상황 가정

</br>

어떤 게임을 보면 수행 도중에 ESC 키를 눌러도 빠져나가지 않는 것들이 존재한다. 

예를 들면 현재 캐릭터가 움직이고 있는 중이라면 무조건 방향 키만 사용할 것을 요구하는 경우다.

이벤트 모드를 수용하지 않고 리퀘스트 모드를 사용한 프로그램일 경우 이러한 일이 발생할 수 있다.

</br>

ESC가 이벤트 루프를 빠져나가는 키라고 가정할 때, 이벤트 모드에서 입력을 처리하는 과정을 유사 코드로 나타내면 다음과 같다.

</br>

```
Initialize Input Devices;

do
{
    if(There if an Event on the Event Queue)
        switch(Event Type)
        {
            case Keyboard Event:
                Get Event Record, Run Callback Function. Respond;
            
            case Mouse Event:
                Get Event Record, Run Callback Function. Respond;

            ...
        }
    else
        Do Background Process
} while(User doesn't request Escape);
```
</br>

처음 입력 장치를 초기화한 이후 모든 이벤트는 루프에 의해 처리된다.

즉, 사용자가 Escape 명령을 내리기 전까지는 이벤트 큐에 쌓인 레코드를 순차적으로 처리하는 과정이 반복된다.

만약 이벤트가 없다면 운영체제는 현재 실행되는 응용프로그램이 아닌 다른 백그라운드 작업을 실행하면서 이벤트 큐를 주기적으로 검사한다.

</br>

MS Windows도 일종의 이벤트 구동 시스템이다.

Windows 프로그램의 시작점은 WinMain()이라는 함수로, 이 함수는 새로운 윈도우를 생성하는 즉시, 이벤트를 처리하는 루프로 진입한다.

윈도우의 이벤트 레코드는 이벤트 메시지 형식으로 처리된다. 이 메시지는 윈도우 핸들, 메시지 타입, 파라미터 등의 메저 정보로 구성된다.

윈도우의 이벤트 처리는 응용프로그램에 의해 직접 실행할 수 있지만, GLUT API를 이용하면 더욱 쉬워진다.